// --------------------------------------------------------------------
// Helpers

var second = function(x) { return x[1]; };

var toWords = function(x) { return x.split(' '); };


var observe = function(dist, val) {
  if (val !== undefined) {
    factor(dist.score(val));
    return val;
  } else {
    return sample(dist, {
      guide() {
        return dist; // prevent auto-guide in Forward; always use model dist
      }
    });
  }
};


_.defaults(global, { webpplCache: {} });

var globalCache = global.webpplCache;

var cached = function(fn) {
  return function(x) {
    if (_.has(globalCache, x)) {
      return globalCache[x];
    } else {
      var value = fn(x);
      _.assign(globalCache, _.zipObject([x], [value]));
      return value;
    }
  }
};


var addTerminal = function(xs) {
  return xs.concat(['$']);
};

var removeTerminal = function(xs) {
  if ((xs.length === 0) || (xs[xs.length - 1] !== '$')) {
    return xs;
  }
  return xs.slice(0, xs.length - 1);
};

var wordsToString = function(xs) {
  return removeTerminal(xs).join(' ');
};

var reduceLeft = function(f, init, arr) {
  // if (arr.length > 0) {
  //   return reduceLeft(f, f(init, arr[0]), rest(arr));
  // } else {
  //   return init;
  // }
  var helper = function(i, init) {
    if (i < arr.length) {
      return helper(i + 1, f(init, arr[i]));
    } else {
      return init;
    }
  };
  return helper(0, init);
};


// --------------------------------------------------------------------
// Load babi dialog task 1 data

var parseLine = function(rawLine) {
  var i = rawLine.indexOf(' '); // 
  var line = rawLine.slice(i + 1);
  var utterances = line.split('\t');
  assert.equal(utterances.length, 2);
  return utterances;
}

var parseDialog = function(rawDialog) {
  var rawLines = rawDialog.split('\n');
  return map(parseLine, rawLines);
};

var load = function(fn) {
  var raw = fs.read(fn).trim();
  return map(parseDialog, raw.split('\n\n'));
}

var trainingData = load('/data/dialog-models/dialog-babi-task1/dialog-babi-task1-API-calls-trn.txt');

var devData = load('/data/dialog-models/dialog-babi-task1/dialog-babi-task1-API-calls-dev.txt').slice(0, 10);

// Note: I'm telling the model about the possible words in the dev data as well!
var words = _.sortBy(_.uniq(_.flatten(map(toWords, _.flattenDeep(_.concat(trainingData, devData)))).concat(['^', '$'])));


// --------------------------------------------------------------------
// Encoder + decoder

var latentDim = 30;

var onehotWords = cached(function(word) {
  var i = _.indexOf(words, word);
  assert.ok(i != -1, "onehot expected to find word in words, didn't find " + word + " in " + words);
  var n = words.length;
  return oneHot(i, n);
});

var makeModelParam = param; // modelParamL2(10);

var makeEncoderStep = function() {
  var enc_net = stack([tanh, affine(latentDim, 'enc-h', makeModelParam), concat]);
  return function(prevState, x) {
    assert.ok(dims(prevState)[0] === latentDim, 'Previous hidden vector has unexpected dimension');
    var nextState = enc_net([prevState, onehotWords(x)]);
    return nextState;
  };
};

var makeInitialEncoderState = function() {
  return makeModelParam({ name: 'enc-init', dims: [latentDim, 1] });
};

// Encoder repeats encoder step until input is completely digested
var makeEncoder = function() {
  var encoderStep = makeEncoderStep();
  var encoder = function(xs, maybeState) {    
    var state = maybeState || makeInitialEncoderState();
    if (xs.length === 0) {
      return state;
    } else {
      var nextState = encoderStep(state, xs[0]);
      return encoder(xs.slice(1), nextState);
    }
  };
  return encoder;
};

var makeDecoderStep = function() {
  var dec_net_h = stack([tanh, affine(latentDim, 'dec-h', makeModelParam), concat]);
  var dec_net_out = stack([softmax, affine(words.length, 'dec-out', makeModelParam), concat]);
  return function(x_prev, state) {
    assert.ok(dims(state)[0] === latentDim, 'Previous hidden vector has unexpected dimension');
    var k = onehotWords(x_prev);
    var nextState = dec_net_h([state, k]);
    var ps = dec_net_out([nextState, k]);
    return { ps, state: nextState }
  };
};

// Decoder repeats decoder step until terminal symbol is observed or max length is exceeded
var makeDecoder = function(maxSeqLength) {
  var decoderStep = makeDecoderStep();
  var decoder = function(opts) {
    var state = opts.state;
    var n = opts.n || 0;
    var generatedSeq = opts.generatedSeq || ['^'];
    var remainingSeq = opts.remainingSeq;
    var x_prev = _.last(generatedSeq);
    if ((n === (maxSeqLength + 2)) || (x_prev === '$')) {
      // We're not slicing off the terminal symbol since not all strings self-terminate,
      // and we might like to know which do
      return generatedSeq.slice(1);
    } else {
      var tmp = decoderStep(x_prev, state);
      var nextState = tmp.state;
      var ps = tmp.ps;
      var observedX = remainingSeq ? remainingSeq[0] : undefined;
      var generatedX = observe(Categorical({ ps, vs: words }), observedX);
      return decoder({
        state: nextState,
        n: n+1,
        generatedSeq: generatedSeq.concat([ generatedX ]),
        remainingSeq: remainingSeq ? remainingSeq.slice(1) : undefined
      });
    }
  };
  return decoder;
};


// --------------------------------------------------------------------
// Main


var encoder = makeEncoder();

var decoder = makeDecoder(10);


var runModel = function(options) { // data, withObservations, callback, batchSize

  var initialEncoderState = makeInitialEncoderState();
  mapData({ data: options.data, batchSize: options.batchSize }, function(datum) {
    
    reduceLeft(function (prevState, x) {
      var utterance = addTerminal(toWords(x[0]));
      var trueResponse = addTerminal(toWords(x[1]));
      var midState = encoder(utterance, prevState);
      var modelResponse = decoder({
        state: midState,
        remainingSeq: options.withObservations ? trueResponse : undefined
      });
      if (options.callbackOnExchange) {
        var callback = options.callbackOnExchange;
        callback(utterance, trueResponse, modelResponse);
      }
      var state = encoder(trueResponse, midState);
      return state;
    }, initialEncoderState, datum);

    if (options.callbackOnDialog) {
      var callback = options.callbackOnDialog;
      callback();
    }
    
  });

};


Optimize({
  model() {
    return runModel({
      data: trainingData,
      withObservations: true,
      batchSize: 20
    });
  },
  steps: 300,
  optMethod: { adam: { stepSize: .01 }}
});


runModel({
  data: devData,
  callbackOnExchange(utterance, trueResponse, modelResponse) {
    console.log('Input: ', wordsToString(utterance));
    console.log('True response: ', wordsToString(trueResponse));
    console.log('Model response: ', wordsToString(modelResponse));
    console.log()
  },
  callbackOnDialog() {
    console.log('--------------------------------------------------------------------');
  }
})

'done'


// Output:
//
// Input:  hello
// True response:  hello what can i help you with today
// Model response:  hello what can i help you with today
// 
// Input:  can you book a table for six people with french food
// True response:  i'm on it
// Model response:  i'm on it
// 
// Input:  <SILENCE>
// True response:  where should it be
// Model response:  ok let me look into some options for you
// 
// Input:  in bombay
// True response:  which price range are looking for
// Model response:  i'm on it
// 
// Input:  i am looking for a cheap restaurant
// True response:  ok let me look into some options for you
// Model response:  ok let me look into some options for you
// 
// Input:  <SILENCE>
// True response:  api_call french bombay six cheap
// Model response:  api_call french paris two moderate
// 
// --------------------------------------------------------------------
// 
// Input:  hi
// True response:  hello what can i help you with today
// Model response:  hello what can i help you with today
// 
// Input:  can you make a restaurant reservation with italian cuisine for six people in a cheap price range
// True response:  i'm on it
// Model response:  i'm on it
// 
// Input:  <SILENCE>
// True response:  where should it be
// Model response:  where should it be
// 
// Input:  rome please
// True response:  ok let me look into some options for you
// Model response:  how many people would be in your party
// 
// Input:  <SILENCE>
// True response:  api_call italian rome six cheap
// Model response:  api_call french rome six expensive
// 
// ...